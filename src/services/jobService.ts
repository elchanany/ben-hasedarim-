import { Job, JobDifficulty, PaymentType, JobPosterInfo, JobDateType, PaymentMethod, PreferredContactMethods, JobSuitability, JobSearchFilters } from '../types';
import { db } from '@/lib/firebase'; // Import Firestore instance
import {
  collection,
  addDoc,
  updateDoc,
  deleteDoc,
  doc,
  getDocs,
  getDoc,
  query,
  where,
  orderBy,
  limit,
  startAfter,
  Timestamp,
  serverTimestamp,
  increment,
  runTransaction,
  writeBatch,
  onSnapshot,
  Unsubscribe,
  QuerySnapshot,
  DocumentSnapshot
} from 'firebase/firestore';
import { ISRAELI_CITIES, DEFAULT_USER_DISPLAY_NAME, SortById } from '../constants';
import { getTodayGregorianISO } from '../utils/dateConverter';
import * as adminLogService from './adminLogService';
import * as notificationService from './notificationService';
import { AdminLog } from '../types';

const JOBS_COLLECTION = 'jobs';

// Helper to convert Firestore Timestamps to ISO strings if they exist in the doc data
const convertTimestamps = (docData: any) => {
  const data = { ...docData };
  for (const key in data) {
    // Handle Firestore Timestamp instances
    if (data[key] instanceof Timestamp) {
      data[key] = data[key].toDate().toISOString();
    }
    // Handle plain objects with seconds/nanoseconds (serialized Timestamps)
    else if (data[key] && typeof data[key] === 'object' && 'seconds' in data[key]) {
      data[key] = new Date(data[key].seconds * 1000).toISOString();
    }
    // Handle serverTimestamp placeholders that weren't converted by Firestore
    else if (data[key] && typeof data[key] === 'object' && data[key]._methodName === 'serverTimestamp') {
      console.warn(`[convertTimestamps] Found serverTimestamp placeholder in field '${key}', replacing with current time`);
      data[key] = new Date().toISOString();
    }
  }
  return data;
};


// Helper to recursively remove undefined values from an object
const removeUndefined = (obj: any): any => {
  if (typeof obj !== 'object' || obj === null) return obj;
  if (Array.isArray(obj)) return obj.map(removeUndefined);

  return Object.entries(obj).reduce((acc: any, [key, value]) => {
    if (value !== undefined) {
      acc[key] = removeUndefined(value);
    }
    return acc;
  }, {});
};

// --- Mock data initialization (for demonstration if needed, otherwise remove) ---
const initializeMockJobsInFirestore = async () => {
  const jobsCollectionRef = collection(db, JOBS_COLLECTION);
  const snapshot = await getDocs(query(jobsCollectionRef, limit(1)));
  if (snapshot.empty) {
    console.log("No jobs in Firestore, initializing mock jobs...");
    const mockUserPoster1: JobPosterInfo = { id: 'firebase_mock_user_1', posterDisplayName: 'משה לוי (בדיקה)' };
    const mockJobs = [
      {
        // id is auto-generated by Firestore
        title: 'הובלה קטנה בירושלים (Firestore)',
        area: 'ירושלים',
        dateType: 'today',
        specificDate: getTodayGregorianISO(),
        startTime: '14:00',
        estimatedDurationHours: 2,
        estimatedDurationIsFlexible: false,
        difficulty: JobDifficulty.MEDIUM,
        paymentType: PaymentType.GLOBAL,
        globalPayment: 200,
        description: 'דרוש בחור חזק להובלת מספר רהיטים קטנים. (מתוך Firestore)',
        specialRequirements: 'יכולת הרמה, זריזות.',
        suitability: { men: true, women: false, general: false, minAge: 18 },
        numberOfPeopleNeeded: 1,
        paymentMethod: PaymentMethod.CASH_ON_COMPLETION,
        contactInfoSource: 'currentUser',
        contactDisplayName: 'משה לוי (בדיקה)',
        contactPhone: '050-1111111',
        preferredContactMethods: { phone: true, whatsapp: true, email: false, allowSiteMessages: true },
        postedBy: mockUserPoster1,
        postedDate: serverTimestamp(), // Use Firestore server timestamp
        views: 0,
        contactAttempts: 0,
        isFlagged: false,
      },
      // Add more mock jobs if needed
    ];
    const batch = writeBatch(db);
    mockJobs.forEach(job => {
      const jobRef = doc(collection(db, JOBS_COLLECTION)); // Firestore will generate ID
      batch.set(jobRef, job);
    });
    await batch.commit();
    console.log("Mock jobs initialized in Firestore.");
  }
};
// Call this once, perhaps in App.tsx or a Firebase initialization script, guarded by an environment check.
// initializeMockJobsInFirestore(); // Be cautious with this in production.

// --- Firestore based jobService functions ---

export const isJobDateValidForSearch = (job: Job): boolean => {
  // This logic remains mostly the same, assuming job.specificDate and job.postedDate are ISO strings
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  if (job.dateType === 'flexibleDate') return true;

  if (job.dateType === 'comingWeek') {
    const jobDateForComparison = job.specificDate ? new Date(job.specificDate) : new Date(job.postedDate);
    jobDateForComparison.setHours(0, 0, 0, 0);

    const sevenDaysFromComparison = new Date(jobDateForComparison);
    sevenDaysFromComparison.setDate(jobDateForComparison.getDate() + 7);

    return sevenDaysFromComparison >= today;
  }
  if (job.dateType === 'today' || job.dateType === 'specificDate') {
    if (!job.specificDate) return false;
    const specificJobDate = new Date(job.specificDate);
    specificJobDate.setHours(0, 0, 0, 0);
    return specificJobDate >= today;
  }
  return true;
};


export const getHotJobs = async (jobLimit: number = 4): Promise<Job[]> => {
  const jobsCol = collection(db, JOBS_COLLECTION);

  // Fetch more jobs than needed, sorted by recent first
  // We'll calculate engagement score client-side since Firestore can't do calculated fields
  const q = query(jobsCol,
    where("postedDate", "<=", new Date().toISOString()),
    orderBy("postedDate", "desc"),
    limit(jobLimit * 3)); // Fetch 3x to have enough candidates

  const querySnapshot = await getDocs(q);
  const jobs: Job[] = [];

  querySnapshot.forEach((docSnap) => {
    jobs.push({ id: docSnap.id, ...convertTimestamps(docSnap.data()) } as Job);
  });

  // Filter to valid jobs first
  const validJobs = jobs.filter(isJobDateValidForSearch);

  // Calculate engagement score for each job
  // Score = (views × 1.0) + (applicationCount × 3.0)
  // Applications are weighted 3x because they show stronger user interest
  const jobsWithScore = validJobs.map(job => ({
    job,
    score: (job.views || 0) * 1.0 + (job.applicationCount || 0) * 3.0
  }));

  // Sort by engagement score descending
  jobsWithScore.sort((a, b) => b.score - a.score);

  // Check if all jobs have zero engagement
  const allZeroEngagement = jobsWithScore.every(item => item.score === 0);

  if (allZeroEngagement) {
    // Fallback: return most recent jobs
    return validJobs.slice(0, jobLimit);
  }

  // Return top jobs by engagement
  return jobsWithScore.slice(0, jobLimit).map(item => item.job);
};

export interface SearchCriteria extends JobSearchFilters { }

export const searchJobs = async (criteria: Partial<SearchCriteria>): Promise<Job[]> => {
  // BASE FETCH: Fetch a larger batch of recent jobs to filter in-memory.
  // This avoids the "missing index" requirement for dynamic composite queries.
  // 1000 jobs is reasonable for client-side filtering in this context.
  const jobsCol = collection(db, JOBS_COLLECTION);
  const q = query(jobsCol, orderBy("postedDate", "desc"), limit(1000));

  const querySnapshot = await getDocs(q);
  let allRecentJobs: Job[] = [];
  querySnapshot.forEach((docSnap) => {
    allRecentJobs.push({ id: docSnap.id, ...convertTimestamps(docSnap.data()) } as Job);
  });

  // CLIENT-SIDE FILTERING
  let filteredJobs = allRecentJobs;

  // 1. Text Search (Term)
  if (criteria.term) {
    const searchTerm = criteria.term.toLowerCase().trim();
    filteredJobs = filteredJobs.filter(job =>
      job.title.toLowerCase().includes(searchTerm) ||
      job.description.toLowerCase().includes(searchTerm)
    );
  }

  // 2. Location
  if (criteria.location) {
    const filterLocation = criteria.location.trim();
    filteredJobs = filteredJobs.filter(job =>
      job.area && job.area.trim() === filterLocation
    );
  }

  // 3. Difficulty
  if (criteria.difficulty) {
    filteredJobs = filteredJobs.filter(job => job.difficulty === criteria.difficulty);
  }

  // 4. Date Type & Specific Dates
  if (criteria.dateType) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    if (criteria.dateType === 'today') {
      const todayISO = getTodayGregorianISO();
      filteredJobs = filteredJobs.filter(job => job.specificDate === todayISO || job.dateType === 'today');
    } else if (criteria.dateType === 'comingWeek') {
      const oneWeekFromToday = new Date(today);
      oneWeekFromToday.setDate(today.getDate() + 7);
      filteredJobs = filteredJobs.filter(job => {
        if (!job.specificDate) return job.dateType === 'flexibleDate';
        const jobDate = new Date(job.specificDate);
        return jobDate >= today && jobDate <= oneWeekFromToday;
      });
    } else if (criteria.dateType === 'flexibleDate') {
      filteredJobs = filteredJobs.filter(job => job.dateType === 'flexibleDate');
    } else if (criteria.dateType === 'specificDate') {
      if (criteria.specificDateStart) {
        const startDate = new Date(criteria.specificDateStart);
        startDate.setHours(0, 0, 0, 0);
        const endDate = criteria.specificDateEnd ? new Date(criteria.specificDateEnd) : startDate;
        endDate.setHours(23, 59, 59, 999);

        filteredJobs = filteredJobs.filter(job => {
          if (!job.specificDate) return false;
          const jobDate = new Date(job.specificDate);
          return jobDate >= startDate && jobDate <= endDate;
        });
      }
    }
  }

  // 5. Payment Kind & Rates - FIXED: Now works with 'any' mode
  if (criteria.paymentKind && criteria.paymentKind !== 'any') {
    filteredJobs = filteredJobs.filter(job => job.paymentType === criteria.paymentKind);
  }

  // Apply hourly rate filters (works in 'any' mode too)
  if (criteria.minHourlyRate || criteria.maxHourlyRate) {
    filteredJobs = filteredJobs.filter(job => {
      if (job.paymentType !== PaymentType.HOURLY) return criteria.paymentKind === 'any'; // Include if 'any', exclude if specific

      const rate = job.hourlyRate || 0;
      const minOk = !criteria.minHourlyRate || rate >= parseFloat(criteria.minHourlyRate);
      const maxOk = !criteria.maxHourlyRate || rate <= parseFloat(criteria.maxHourlyRate);
      return minOk && maxOk;
    });
  }

  // Apply global payment filters (works in 'any' mode too)
  if (criteria.minGlobalPayment || criteria.maxGlobalPayment) {
    filteredJobs = filteredJobs.filter(job => {
      if (job.paymentType !== PaymentType.GLOBAL) return criteria.paymentKind === 'any';

      const payment = job.globalPayment || 0;
      const minOk = !criteria.minGlobalPayment || payment >= parseFloat(criteria.minGlobalPayment);
      const maxOk = !criteria.maxGlobalPayment || payment <= parseFloat(criteria.maxGlobalPayment);
      return minOk && maxOk;
    });
  }

  // 6. Payment Methods
  if (criteria.selectedPaymentMethods && criteria.selectedPaymentMethods.size > 0) {
    filteredJobs = filteredJobs.filter(job => job.paymentMethod && criteria.selectedPaymentMethods!.has(job.paymentMethod));
  }

  // 7. Duration Flexibility
  if (criteria.filterDurationFlexible && criteria.filterDurationFlexible !== 'any') {
    const isFlexible = criteria.filterDurationFlexible === 'yes';
    filteredJobs = filteredJobs.filter(job => !!job.estimatedDurationIsFlexible === isFlexible);
  }

  // 7a. Estimated Duration Range (Hours) - ADDED: Was completely missing!
  if (criteria.minEstimatedDurationHours) {
    const min = parseFloat(criteria.minEstimatedDurationHours);
    if (!isNaN(min)) {
      filteredJobs = filteredJobs.filter(job => (job.estimatedDurationHours || 0) >= min);
    }
  }
  if (criteria.maxEstimatedDurationHours) {
    const max = parseFloat(criteria.maxEstimatedDurationHours);
    if (!isNaN(max)) {
      filteredJobs = filteredJobs.filter(job => (job.estimatedDurationHours || 0) <= max);
    }
  }

  // 8. People Needed Range
  if (criteria.minPeopleNeeded) {
    const min = parseInt(criteria.minPeopleNeeded);
    filteredJobs = filteredJobs.filter(job => (job.numberOfPeopleNeeded || 0) >= min);
  }
  if (criteria.maxPeopleNeeded) {
    const max = parseInt(criteria.maxPeopleNeeded);
    filteredJobs = filteredJobs.filter(job => (job.numberOfPeopleNeeded || 0) <= max);
  }

  // 9. Suitability
  if (criteria.suitabilityFor && criteria.suitabilityFor !== 'any') {
    filteredJobs = filteredJobs.filter(job => {
      if (!job.suitability) return false;
      return (job.suitability as any)[criteria.suitabilityFor!] === true;
    });
  }

  // 10. Age Range - FIXED: Was inverted logic!
  if (criteria.minAge || criteria.maxAge) {
    filteredJobs = filteredJobs.filter(job => {
      if (!job.suitability?.minAge) return true; // No age restriction = suitable for all

      const jobMinAge = job.suitability.minAge;
      const userMinAge = criteria.minAge ? parseInt(criteria.minAge) : 0;
      const userMaxAge = criteria.maxAge ? parseInt(criteria.maxAge) : 120;

      // Check if job's minimum age falls within user's age range (with 2-year buffer)
      return jobMinAge >= userMinAge - 2 && jobMinAge <= userMaxAge + 2;
    });
  }

  // SORTING
  if (criteria.sortBy === 'hottest') {
    filteredJobs.sort((a, b) => (b.views || 0) - (a.views || 0) || new Date(b.postedDate).getTime() - new Date(a.postedDate).getTime());
  } else if (criteria.sortBy === 'highestPay') {
    filteredJobs.sort((a, b) => {
      const payA = a.paymentType === PaymentType.GLOBAL ? (a.globalPayment || 0) : (a.hourlyRate || 0) * 8; // Normalized approx
      const payB = b.paymentType === PaymentType.GLOBAL ? (b.globalPayment || 0) : (b.hourlyRate || 0) * 8;
      return payB - payA || new Date(b.postedDate).getTime() - new Date(a.postedDate).getTime();
    });
  } else {
    // Default newest
    filteredJobs.sort((a, b) => new Date(b.postedDate).getTime() - new Date(a.postedDate).getTime());
  }

  // FINAL DATE VALIDATION (Security/Cleanup)
  filteredJobs = filteredJobs.filter(isJobDateValidForSearch);

  return filteredJobs;
};


export const getJobById = async (id: string): Promise<Job | undefined> => {
  const docRef = doc(db, JOBS_COLLECTION, id);
  const docSnap = await getDoc(docRef);
  if (docSnap.exists()) {
    const jobData = convertTimestamps(docSnap.data());
    const preferredContacts = jobData.preferredContactMethods || { phone: true, whatsapp: false, email: false, allowSiteMessages: false };
    if (typeof preferredContacts.allowSiteMessages === 'undefined') {
      preferredContacts.allowSiteMessages = false;
    }
    return { id: docSnap.id, ...jobData, preferredContactMethods: preferredContacts } as Job;
  }
  return undefined;
};

export const incrementJobView = async (jobId: string): Promise<void> => {
  const jobRef = doc(db, JOBS_COLLECTION, jobId);
  const jobSnap = await getDoc(jobRef);
  if (jobSnap.exists()) {
    await updateDoc(jobRef, {
      views: (jobSnap.data().views || 0) + 1
    });
  }
};

export const incrementJobContactAttempt = async (jobId: string): Promise<void> => {
  const jobRef = doc(db, JOBS_COLLECTION, jobId);
  const jobSnap = await getDoc(jobRef);
  if (jobSnap.exists()) {
    await updateDoc(jobRef, {
      contactAttempts: (jobSnap.data().contactAttempts || 0) + 1
    });
  }
};

export const addJob = async (jobData: Omit<Job, 'id' | 'postedDate' | 'views' | 'contactAttempts' | 'serialNumber'>): Promise<Job> => {
  console.log("Adding job with payload:", JSON.stringify(jobData, null, 2)); // DEBUG: Verify contact methods

  try {
    const jobPayload: any = {
      ...jobData,
      postedDate: new Date().toISOString(), // Use actual ISO timestamp instead of placeholder
      views: 0,
      contactAttempts: 0,
      isFlagged: false, // Default for new jobs
      flagReason: '',   // Default for new jobs
    };
    if (jobPayload.dateType === 'today' && !jobPayload.specificDate) {
      jobPayload.specificDate = getTodayGregorianISO();
    }
    if (typeof jobPayload.preferredContactMethods.allowSiteMessages === 'undefined') {
      jobPayload.preferredContactMethods.allowSiteMessages = false;
    }

    const cleanJobPayload = removeUndefined(jobPayload);

    // Use Transaction to get and increment serial number, then write job
    return await runTransaction(db, async (transaction) => {
      const counterRef = doc(db, 'counters', 'jobs');
      const counterSnap = await transaction.get(counterRef);

      let nextSerial = 1000; // Default start
      if (counterSnap.exists()) {
        const current = counterSnap.data().current;
        if (typeof current === 'number') {
          nextSerial = current + 1;
        }
      }

      // Set the serial number on the job
      cleanJobPayload.serialNumber = nextSerial;

      // Create a new ID for the job
      const newJobRef = doc(collection(db, JOBS_COLLECTION));
      const publicProfileRef = doc(db, 'public_profiles', jobData.postedBy.id);

      // Writes
      transaction.set(counterRef, { current: nextSerial }, { merge: true });
      transaction.set(newJobRef, cleanJobPayload);

      // Increment jobs published count for the user and ensure basic profile data exists
      transaction.set(publicProfileRef, {
        jobsPublishedCount: increment(1),
        lastActive: new Date().toISOString(),
        displayName: jobData.postedBy.posterDisplayName // Ensure name exists for new/dormant users
      }, { merge: true });

      const createdJob = { ...cleanJobPayload, id: newJobRef.id, postedDate: new Date().toISOString() } as Job;

      // Trigger notifications for all users with matching job alerts
      setTimeout(() => {
        notificationService.checkAllAlertsForNewJob(createdJob);
      }, 100); // Small delay to ensure transaction commits

      return createdJob;
    });

  } catch (error) {
    console.error("Error adding job to Firestore:", error);
    throw error;
  }
};

export const updateJob = async (jobId: string, updatedData: Partial<Job>): Promise<Job | undefined> => {
  const jobRef = doc(db, JOBS_COLLECTION, jobId);
  const updatePayload: Partial<Job> = { ...updatedData };

  Object.keys(updatePayload).forEach(key =>
    updatePayload[key as keyof typeof updatePayload] === undefined && delete updatePayload[key as keyof typeof updatePayload]
  );

  if (updatePayload.dateType === 'today' && !updatePayload.specificDate) {
    updatePayload.specificDate = getTodayGregorianISO();
  }
  if (updatePayload.paymentMethod === PaymentMethod.CASH_ON_COMPLETION) {
    updatePayload.paymentDueDate = undefined;
  }
  if (updatePayload.preferredContactMethods && typeof updatePayload.preferredContactMethods.allowSiteMessages === 'undefined') {
    const currentJob = await getJobById(jobId);
    updatePayload.preferredContactMethods.allowSiteMessages = currentJob?.preferredContactMethods.allowSiteMessages ?? false;
  }
  // Ensure isFlagged is explicitly set if not provided, to avoid removing it accidentally
  if (updatePayload.isFlagged === undefined && updatePayload.flagReason !== undefined) {
    // If only reason is provided, assume it's being flagged
    updatePayload.isFlagged = true;
  } else if (updatePayload.isFlagged === false) {
    // If unflagging, clear the reason
    updatePayload.flagReason = '';
  }


  // Perform deep clean right before sending to Firestore
  const cleanUpdatePayload = removeUndefined(updatePayload);

  await updateDoc(jobRef, cleanUpdatePayload);
  return getJobById(jobId);
};

export const getJobsByUserId = async (userId: string): Promise<Job[]> => {
  // Query without orderBy to avoid requiring a composite index in Firestore
  const q = query(collection(db, JOBS_COLLECTION), where("postedBy.id", "==", userId));
  const querySnapshot = await getDocs(q);
  const jobs: Job[] = [];
  querySnapshot.forEach((docSnap) => {
    jobs.push({ id: docSnap.id, ...convertTimestamps(docSnap.data()) } as Job);
  });
  // Sort client-side by postedDate descending (newest first)
  jobs.sort((a, b) => new Date(b.postedDate).getTime() - new Date(a.postedDate).getTime());
  return jobs;
};

export const deleteJob = async (jobId: string, adminLogData?: Omit<AdminLog, 'id' | 'timestamp'>): Promise<void> => {
  // Security for this action MUST be handled by Firestore Security Rules (admin/moderator or owner only)
  try {
    const jobRef = doc(db, JOBS_COLLECTION, jobId);
    let jobData: DocumentSnapshot | null = null;

    // Fetch job first to identify the poster for decrementing count
    const snap = await getDoc(jobRef);
    if (snap.exists()) {
      jobData = snap;
      if (adminLogData && !adminLogData.details) {
        adminLogData.details = JSON.stringify(snap.data());
      }
    }

    await deleteDoc(jobRef);

    // Decrement jobs published count for the user
    if (jobData && jobData.exists()) {
      const data = jobData.data();
      if (data && data.postedBy && data.postedBy.id) {
        const publicProfileRef = doc(db, 'public_profiles', data.postedBy.id);
        await updateDoc(publicProfileRef, {
          jobsPublishedCount: increment(-1)
        }).catch(err => console.warn("Failed to decrement job count", err));
      }
    }

    if (adminLogData) {
      await adminLogService.logAction(adminLogData);
    }
  } catch (error) {
    console.error("Error deleting job:", error);
    throw error;
  }
};

export const flagJobAdmin = async (jobId: string, reason: string, flag: boolean): Promise<void> => {
  // Security for this action MUST be handled by Firestore Security Rules (admin/moderator only)
  const jobRef = doc(db, JOBS_COLLECTION, jobId);
  await updateDoc(jobRef, {
    isFlagged: flag,
    flagReason: flag ? reason : '' // Clear reason if unflagging
  });
};


export const getAllJobs = async (): Promise<Job[]> => {
  // Security: This should be restricted to admins/moderators by Firestore Security Rules
  const jobsCol = collection(db, JOBS_COLLECTION);
  const q = query(jobsCol, orderBy("postedDate", "desc"));
  const querySnapshot = await getDocs(q);
  const jobs: Job[] = [];
  querySnapshot.forEach((docSnap) => {
    jobs.push({ id: docSnap.id, ...convertTimestamps(docSnap.data()) } as Job);
  });
  return jobs;
};

export const incrementApplicationCount = async (jobId: string) => {
  const jobRef = doc(db, 'jobs', jobId);
  await updateDoc(jobRef, {
    applicationCount: increment(1)
  });
};