import { Job, JobDifficulty, PaymentType, JobPosterInfo, JobDateType, PaymentMethod, PreferredContactMethods, JobSuitability, JobSearchFilters } from '../../types';
import { db } from '../firebaseConfig'; // Import Firestore instance
import { 
    collection, 
    doc, 
    addDoc, 
    getDoc, 
    getDocs, 
    updateDoc, 
    deleteDoc, 
    query, 
    where, 
    orderBy, 
    limit,
    serverTimestamp, 
    Timestamp,
    writeBatch
} from "firebase/firestore";
import { ISRAELI_CITIES, DEFAULT_USER_DISPLAY_NAME, SortById } from '../../constants'; 
import { getTodayGregorianISO } from '../../utils/dateConverter';

const JOBS_COLLECTION = 'jobs';

// Helper to convert Firestore Timestamps to ISO strings if they exist in the doc data
const convertTimestamps = (docData: any) => {
    const data = { ...docData };
    for (const key in data) {
        if (data[key] instanceof Timestamp) {
            data[key] = data[key].toDate().toISOString();
        }
    }
    return data;
};


// --- Mock data initialization (for demonstration if needed, otherwise remove) ---
const initializeMockJobsInFirestore = async () => {
    const jobsCollectionRef = collection(db, JOBS_COLLECTION);
    const snapshot = await getDocs(query(jobsCollectionRef, limit(1)));
    if (snapshot.empty) {
        console.log("No jobs in Firestore, initializing mock jobs...");
        const mockUserPoster1: JobPosterInfo = { id: 'firebase_mock_user_1', posterDisplayName: 'משה לוי (בדיקה)' };
        const mockJobs = [
             {
                // id is auto-generated by Firestore
                title: 'הובלה קטנה בירושלים (Firestore)',
                area: 'ירושלים',
                dateType: 'today',
                specificDate: getTodayGregorianISO(),
                startTime: '14:00',
                estimatedDurationHours: 2,
                estimatedDurationIsFlexible: false,
                difficulty: JobDifficulty.MEDIUM,
                paymentType: PaymentType.GLOBAL,
                globalPayment: 200,
                description: 'דרוש בחור חזק להובלת מספר רהיטים קטנים. (מתוך Firestore)',
                specialRequirements: 'יכולת הרמה, זריזות.',
                suitability: { men: true, women: false, general: false, minAge: 18 },
                numberOfPeopleNeeded: 1,
                paymentMethod: PaymentMethod.CASH_ON_COMPLETION,
                contactInfoSource: 'currentUser', 
                contactDisplayName: 'משה לוי (בדיקה)',
                contactPhone: '050-1111111',
                preferredContactMethods: { phone: true, whatsapp: true, email: false, allowSiteMessages: true }, 
                postedBy: mockUserPoster1,
                postedDate: serverTimestamp(), // Use Firestore server timestamp
                views: 0,
                contactAttempts: 0,
                isFlagged: false,
            },
            // Add more mock jobs if needed
        ];
        const batch = writeBatch(db);
        mockJobs.forEach(job => {
            const jobRef = doc(collection(db, JOBS_COLLECTION)); // Firestore will generate ID
            batch.set(jobRef, job);
        });
        await batch.commit();
        console.log("Mock jobs initialized in Firestore.");
    }
};
// Call this once, perhaps in App.tsx or a Firebase initialization script, guarded by an environment check.
// initializeMockJobsInFirestore(); // Be cautious with this in production.

// --- Firestore based jobService functions ---

export const isJobDateValidForSearch = (job: Job): boolean => {
    // This logic remains mostly the same, assuming job.specificDate and job.postedDate are ISO strings
    const today = new Date();
    today.setHours(0, 0, 0, 0); 

    if (job.dateType === 'flexibleDate') return true; 
    
    if (job.dateType === 'comingWeek') {
        const jobDateForComparison = job.specificDate ? new Date(job.specificDate) : new Date(job.postedDate);
        jobDateForComparison.setHours(0,0,0,0);
        
        const sevenDaysFromComparison = new Date(jobDateForComparison);
        sevenDaysFromComparison.setDate(jobDateForComparison.getDate() + 7);
        
        return sevenDaysFromComparison >= today;
    }
    if (job.dateType === 'today' || job.dateType === 'specificDate') {
        if (!job.specificDate) return false; 
        const specificJobDate = new Date(job.specificDate);
        specificJobDate.setHours(0,0,0,0); 
        return specificJobDate >= today;
    }
    return true; 
};


export const getHotJobs = async (jobLimit: number = 4): Promise<Job[]> => {
  const jobsCol = collection(db, JOBS_COLLECTION);
  const q = query(jobsCol, 
                  where("postedDate", "<=", new Date().toISOString()), 
                  orderBy("views", "desc"), 
                  orderBy("postedDate", "desc"), 
                  limit(jobLimit * 2)); 

  const querySnapshot = await getDocs(q);
  const jobs: Job[] = [];
  querySnapshot.forEach((docSnap) => {
    jobs.push({ id: docSnap.id, ...convertTimestamps(docSnap.data()) } as Job);
  });
  
  return jobs.filter(isJobDateValidForSearch).slice(0, jobLimit);
};

export interface SearchCriteria extends JobSearchFilters {}

export const searchJobs = async (criteria: Partial<SearchCriteria>): Promise<Job[]> => {
    let q = query(collection(db, JOBS_COLLECTION));

    if (criteria.location) {
        q = query(q, where("area", "==", criteria.location));
    }
    if (criteria.difficulty) {
        q = query(q, where("difficulty", "==", criteria.difficulty));
    }

    if (criteria.dateType === 'today' || (criteria.dateType === 'specificDate' && criteria.specificDateStart)) {
        const dateToQuery = criteria.dateType === 'today' ? getTodayGregorianISO() : criteria.specificDateStart!;
        const startDate = new Date(dateToQuery); 
        startDate.setHours(0,0,0,0);
        
        let endDate = startDate;
        if (criteria.dateType === 'specificDate' && criteria.specificDateEnd) {
            endDate = new Date(criteria.specificDateEnd);
        }
        endDate.setHours(23,59,59,999);

        q = query(q, where("specificDate", ">=", startDate.toISOString().split('T')[0]));
        q = query(q, where("specificDate", "<=", endDate.toISOString().split('T')[0]));
    } else if (criteria.dateType === 'comingWeek') {
        const today = new Date(); today.setHours(0,0,0,0);
        const oneWeekFromToday = new Date(today); oneWeekFromToday.setDate(today.getDate() + 7);
        q = query(q, where("specificDate", ">=", today.toISOString().split('T')[0]));
        q = query(q, where("specificDate", "<=", oneWeekFromToday.toISOString().split('T')[0]));
    } else if (criteria.dateType === 'flexibleDate') {
        q = query(q, where("dateType", "==", "flexibleDate"));
    }
    
    if (criteria.paymentKind && criteria.paymentKind !== 'any') {
        q = query(q, where("paymentType", "==", criteria.paymentKind));
        if (criteria.paymentKind === PaymentType.HOURLY) {
            if (criteria.minHourlyRate) q = query(q, where("hourlyRate", ">=", parseFloat(criteria.minHourlyRate)));
        } else if (criteria.paymentKind === PaymentType.GLOBAL) {
            if (criteria.minGlobalPayment) q = query(q, where("globalPayment", ">=", parseFloat(criteria.minGlobalPayment)));
        }
    }

    if (criteria.suitabilityFor && criteria.suitabilityFor !== 'any') {
        q = query(q, where(`suitability.${criteria.suitabilityFor}`, "==", true));
    }
    
    let sortByField = "postedDate";
    let sortDirection: "desc" | "asc" = "desc";

    if (criteria.sortBy === 'hottest') {
        q = query(q, orderBy("views", "desc"), orderBy("postedDate", "desc"));
    } else if (criteria.sortBy === 'highestPay') {
        q = query(q, orderBy("globalPayment", "desc"), orderBy("hourlyRate", "desc"), orderBy("postedDate", "desc"));
    } else { 
        q = query(q, orderBy(sortByField, sortDirection));
    }

    const querySnapshot = await getDocs(q);
    let jobs: Job[] = [];
    querySnapshot.forEach((docSnap) => {
        jobs.push({ id: docSnap.id, ...convertTimestamps(docSnap.data()) } as Job);
    });

    if (criteria.term) {
        const searchTerm = criteria.term.toLowerCase();
        jobs = jobs.filter(job =>
            job.title.toLowerCase().includes(searchTerm) ||
            job.description.toLowerCase().includes(searchTerm)
        );
    }
    if (criteria.selectedPaymentMethods && criteria.selectedPaymentMethods.size > 0) {
        jobs = jobs.filter(job => job.paymentMethod && criteria.selectedPaymentMethods!.has(job.paymentMethod));
    }
    jobs = jobs.filter(isJobDateValidForSearch);
    return jobs;
};


export const getJobById = async (id: string): Promise<Job | undefined> => {
  const docRef = doc(db, JOBS_COLLECTION, id);
  const docSnap = await getDoc(docRef);
  if (docSnap.exists()) {
    const jobData = convertTimestamps(docSnap.data());
     const preferredContacts = jobData.preferredContactMethods || { phone: true, whatsapp: false, email: false, allowSiteMessages: false };
      if (typeof preferredContacts.allowSiteMessages === 'undefined') {
          preferredContacts.allowSiteMessages = false;
      }
    return { id: docSnap.id, ...jobData, preferredContactMethods: preferredContacts } as Job;
  }
  return undefined;
};

export const incrementJobView = async (jobId: string): Promise<void> => {
  const jobRef = doc(db, JOBS_COLLECTION, jobId);
  const jobSnap = await getDoc(jobRef);
  if (jobSnap.exists()) {
    await updateDoc(jobRef, {
      views: (jobSnap.data().views || 0) + 1
    });
  }
};

export const incrementJobContactAttempt = async (jobId: string): Promise<void> => {
  const jobRef = doc(db, JOBS_COLLECTION, jobId);
   const jobSnap = await getDoc(jobRef);
  if (jobSnap.exists()) {
    await updateDoc(jobRef, {
      contactAttempts: (jobSnap.data().contactAttempts || 0) + 1
    });
  }
};

export const addJob = async (jobData: Omit<Job, 'id' | 'postedDate' | 'views' | 'contactAttempts'>): Promise<Job> => {
  const jobPayload: any = {
    ...jobData,
    postedDate: serverTimestamp(), 
    views: 0,
    contactAttempts: 0,
    isFlagged: false, // Default for new jobs
    flagReason: '',   // Default for new jobs
  };
  if (jobPayload.dateType === 'today' && !jobPayload.specificDate) {
    jobPayload.specificDate = getTodayGregorianISO();
  }
  if (typeof jobPayload.preferredContactMethods.allowSiteMessages === 'undefined') {
      jobPayload.preferredContactMethods.allowSiteMessages = false;
  }

  const docRef = await addDoc(collection(db, JOBS_COLLECTION), jobPayload);
  return { ...jobPayload, id: docRef.id, postedDate: new Date().toISOString() } as Job; 
};

export const updateJob = async (jobId: string, updatedData: Partial<Job>): Promise<Job | undefined> => {
  const jobRef = doc(db, JOBS_COLLECTION, jobId);
  const updatePayload: Partial<Job> = { ...updatedData };

  Object.keys(updatePayload).forEach(key => 
    updatePayload[key as keyof typeof updatePayload] === undefined && delete updatePayload[key as keyof typeof updatePayload]
  );
  
  if (updatePayload.dateType === 'today' && !updatePayload.specificDate) {
    updatePayload.specificDate = getTodayGregorianISO();
  }
  if (updatePayload.paymentMethod === PaymentMethod.CASH_ON_COMPLETION) {
    updatePayload.paymentDueDate = undefined; 
  }
   if (updatePayload.preferredContactMethods && typeof updatePayload.preferredContactMethods.allowSiteMessages === 'undefined') {
      const currentJob = await getJobById(jobId);
      updatePayload.preferredContactMethods.allowSiteMessages = currentJob?.preferredContactMethods.allowSiteMessages ?? false;
  }
  // Ensure isFlagged is explicitly set if not provided, to avoid removing it accidentally
  if (updatePayload.isFlagged === undefined && updatePayload.flagReason !== undefined) {
    // If only reason is provided, assume it's being flagged
    updatePayload.isFlagged = true;
  } else if (updatePayload.isFlagged === false) {
    // If unflagging, clear the reason
    updatePayload.flagReason = '';
  }


  await updateDoc(jobRef, updatePayload);
  return getJobById(jobId); 
};

export const getJobsByUserId = async (userId: string): Promise<Job[]> => {
  const q = query(collection(db, JOBS_COLLECTION), where("postedBy.id", "==", userId), orderBy("postedDate", "desc"));
  const querySnapshot = await getDocs(q);
  const jobs: Job[] = [];
  querySnapshot.forEach((docSnap) => {
    jobs.push({ id: docSnap.id, ...convertTimestamps(docSnap.data()) } as Job);
  });
  return jobs;
};

export const deleteJob = async (jobId: string): Promise<void> => {
  // Security for this action MUST be handled by Firestore Security Rules (admin/moderator or owner only)
  const jobRef = doc(db, JOBS_COLLECTION, jobId);
  await deleteDoc(jobRef);
};

export const flagJobAdmin = async (jobId: string, reason: string, flag: boolean): Promise<void> => {
  // Security for this action MUST be handled by Firestore Security Rules (admin/moderator only)
  const jobRef = doc(db, JOBS_COLLECTION, jobId);
  await updateDoc(jobRef, {
    isFlagged: flag,
    flagReason: flag ? reason : '' // Clear reason if unflagging
  });
};


export const getAllJobs = async (): Promise<Job[]> => {
    // Security: This should be restricted to admins/moderators by Firestore Security Rules
    const jobsCol = collection(db, JOBS_COLLECTION);
    const q = query(jobsCol, orderBy("postedDate", "desc"));
    const querySnapshot = await getDocs(q);
    const jobs: Job[] = [];
    querySnapshot.forEach((docSnap) => {
        jobs.push({ id: docSnap.id, ...convertTimestamps(docSnap.data()) } as Job);
    });
    return jobs;
};